


valuestream~displays a control's value over time. connect the cable to a UI control to see how it is changing.
~speed~how quickly display should scroll



timerdisplay~displays a timer to indicate how long a patch has been running
~reset~reset timer to zero



timelinecontrol~[abandoned module, possibly broken] global timeline control to position transport
~measure~[todo]
~loop~[todo]
~loop start~[todo]
~loop end~[todo]



selector~radio button control to only enable one value at a time. patch it to the "enabled" checkbox on several modules to only enable one module at a time. works well in conjunction with "groupcontrol" module.
~selector~which value should be set to 1



scriptstatus~shows everything in the current python scope, for debugging
~reset all~resets scope variables



script~python scripting for livecoding notes and module control
~loadscript~choose a script from here, then press "load"
~load~load selected script
~save as~save the current script
~?~show scripting reference
~code~write code here. press ctrl-R to execute the code, or ctrl-shift-R to just execute the current block.
~run~click here to execute the code, or press ctrl-R
~stop~cancel any events scheduled by this script
~a~variable for the script to use, can be modulation by other sources. access via me.get("a")
~b~variable for the script to use, can be modulation by other sources. access via me.get("b")
~c~variable for the script to use, can be modulation by other sources. access via me.get("c")
~d~variable for the script to use, can be modulation by other sources. access via me.get("d")
~style~choose a text theme, from script_styles.json



radiosequencer~sequence to only enable one value at a time. patch it to the "enabled" checkbox on several modules to only enable one module at a time. works well in conjunction with "groupcontrol" module.
~interval~rate to advance
~length~length of sequence
~grid~patch a grid in here from a "midicontroller" module



presets~save and restore sets of values. connect the grey circle to modules to affect all controls on that module. connect the purple circle to a control to affect only that control. shift-click on the grid to store a preset to that square, and click on a grid square to load that preset.
~blend~length of time in milliseconds over which to blend preset values
~preset~jump to a preset
~random~randomize connected controls
~add~snapshot the currently connected controls to the next available preset slot



prefab~create a collection of modules that can be loaded from the "prefabs" menu. drag and drop modules onto here to add them to the prefab. drag the grey cable to any modules you want to remove from the prefab.
~save~save as a .pfb file
~load~load a .pfb
~disband~free all modules from this prefab



oscoutput~send OSC messages when slider values change or when notes are received
~osc out address~destination to send OSC messages to
~osc out port~port to send OSC messages to
~label*~label to send slider value. the message will be sent in the format /bespoke/[label] [value]
~slider*~sends a value to the address. try patching a modulator into this, such as a leveltocv module to send audio levels.
~note out address~label to send input notes. the message will be sent in the format /bespoke/[label] [pitch] [velocity]



loopstorer~[abandoned module, probably broken]store a looper's loops to swap them in and out
~rewrite~[todo]
~quantization~[todo]
~clear~[todo]
~select *~[todo]



loopergranulator~use with a "looper" module to play the contents with granular synthesis
~on~use granular synthesis for looper playback
~overlap~number of overlapping grains
~speed~speed of grain playback
~len ms~length of each grain in milliseconds
~loop pos~playback position within loop
~freeze~stop advancing looper time
~pos rand~randomization of grain start point
~speed rand~randomization of grain speed
~spacing rand~randomization of time between grains
~octaves~should we add octaves and fifths?
~width~stereo width of grain placement



groupcontrol~connect to several checkboxes, and control them all with one checkbox
~group enabled~controls the connected checkboxes



grid~generic grid, to be used by "script" module, to assist in writing scripts that use grid-based midi controllers
~grid~patch a grid in here, from a "midicontroller" module
~momentary~should clicks be treated as momentary inputs?



globalcontrols~interface controls, intended to allow you to use midi controllers to navigate the canvas. controlling these sliders directly with the mouse is not recommended.
~zoom~zoom level
~x pos~horizontal panning position
~y pos~vertical panning position
~scroll x~emulate horizontal mouse scrolling
~scroll y~emulate vertical mouse scrolling
~lissajous r~amount of red in background lissajous curve
~lissajous g~amount of green in background lissajous curve
~lissajous b~amount of blue in background lissajous curve
~background r~amount of red in background color
~background g~amount of green in background color
~background b~amount of blue in background color



eventcanvas~schedule values to set over time
~quantize~quantizes events to grid
~measures~length of loop
~interval~grid for snapping events to
~record~record connected values as they change
~canvas~canvas of events. canvas controls:\n-shift-click to add an event\n-hold shift and drag an event to duplicate\n-hold alt to drag an event without snapping\n-hold ctrl while dragging to snap to an interval\n-hold shift and scroll to zoom\n-hold alt and grab empty space to move slide the canvas view\n-hold ctrl and grab empty space to zoom the canvas view
~timeline~control loop points
~delete~delete highlighted elements
~view rows~number of visible rows
~clear~delete all elements
~drag mode~direction that elements can be dragged
~scrollh~horizontal scrollbar



comment~a box to display some text, to explain a section of a patch
~comment~type text here



clockout~sends out clock pulses to synchronize external midi devices
~device~device to target
~send start~send a signal to reset the gear to the start of its sequence
~multiplier~tempo multiplier for how the gear should respond to the signals



clockin~reads in clock pulses from external midi devices to control bespoke's transport
~device~device to receive from
~rounding~precision to round incoming tempo data
~start offset ms~offset in milliseconds to tweak synchronization between bespoke and gear
~smoothing~how much to smooth incoming tempo



abletonlink~synchronizes transport with software and devices that support ableton link
~offset ms~offset in milliseconds to tweak synchronization



pulsetrain~defines a list of pulses to execute, once pulsed
~length~length of the sequence
~interval~length of each step within the sequence



pulsesequence~defines a looping sequence of pulses
~length~length of the sequence
~interval~length of each step within the sequence
~<~shift sequence to the left
~>~shift sequence to the right



pulser~send pulse messages at an interval
~interval~rate to send pulses
~timemode~when to send downbeat pulses, or set to "free" for pulses not locked to the transport
~t~pulse interval in milliseconds
~offset~pulse time offset, in fractions of the interval
~random~tell pulsed modules to randomize their position
~reset~length of sequence before sending reset pulse
~div~measure division, when using "div" as the interval



pulsehocket~sends pulses to randomized destinations
~weight *~chance that pulse goes to this destination
~seed~number that determines the random sequence. send reset pulses to restart the determined random sequence.
~<~go to previous seed
~*~generate a new random seed
~<~go to next seed



pulsegate~control if pulses are allowed through
~allow~can pulses pass through?



pulsedelayer~delay pulses
~delay~time to delay, in fractions of a measure



pulsechance~randomly allow pulses through, based on chance
~chance~chance that pulses are allowed through
~seed~number that determines the random sequence. send reset pulses to restart the determined random sequence.
~<~go to previous seed
~*~generate a new random seed
~<~go to next seed


pulsebutton~trigger a pulse with a button press
~pulse~trigger a pulse



notetopulse~trigger a pulse whenever a note is received



audiotopulse~sends a pulse when the audio level surpasses a specified threshold
~threshold~send a pulse when the signal hits this threshold
~release~the cooldown time for the audio signal before a pulse can be triggered again



boundstopulse~sends a pulse when its input slider hits its max or min limit
~input~the slider to check bounds on



vinylcontrol~modulator which outputs a speed value based upon control vinyl input audio. provide it with a stereo signal from control vinyl (like you'd use to control serato) patched in from an "input" module.
~control~enable/disable transport control. when you enable it, it will use the current speed as the reference speed (so, the output will output a value of 1 until you change the vinyl's speed)



velocitytocv~take a note's velocity and convert it to a modulation value
~min~output for velocity 0
~max~output for velocity 127
~0 at note off~output zero when note is released



valuesetter~set a specified value on a targeted control
~value~value to set
~set~click here to send the value (or, send a pulse to this module for the same result)
~slider~value to set



subtract~outputs the result of value 2 subtracted from value 1. value 1 and value 2 are intended to be patch targets for modulators.
~value 1~
~value 2~



smoother~outputs a smoothed value of the input
~input~set a value to smooth, patch a modulator into here
~smooth~amount of smoothing to apply



ramper~blend a control to a specified value over a specified time
~length~length of time to blend over
~start~begin blending (or, send a pulse to this module for the same result)
~target~the value to arrive at when the ramp is over



pressuretocv~take a note's pressure and convert it to a modulation value
~min~output for pressure 0
~max~output for pressure 127



pitchtospeed~convert an input pitch to a speed ratio. you could use this to control a sample's playback speed and make it playable with a keyboard.
~ref freq~the output is the input frequency divided by this number



pitchtocv~take a note's pitch and convert it to a modulation value
~min~output for pitch 0
~max~output for pitch 127



notetoms~takes an input note, and outputs the period of that note's frequency in milliseconds. useful for setting delay lines to create specific pitches.



notetofreq~takes an input note, and outputs that note's frequency in hertz



mult~outputs the result of value 1 multiplier by value 2. value 1 and value 2 are intended to be patch targets for modulators.
~value 1~
~value 2~



modwheeltocv~take a note's modwheel value and convert it to a modulation value
~min~output for modwheel value 0
~max~output for modwheel value 127



macroslider~take a value and send scaled versions of that value to multiple destinations
~input~the input value. intended to be a modulation patch target.
~start*~the output value at the bottom of the input's range
~end*~the output value at the top of the input's range



leveltocv~output a modulation value based on the level of incoming audio
~gain~multiply the input audio by this value
~attack~rise to the input level at this rate
~release~decay from the input level at this rate
~min~output when level is zero
~max~output when level is one



gridsliders~use a grid controller to control multiple sliders
~direction~should the grid display the sliders vertically, or horizontally?
~grid~patch a grid in here from a "midicontroller" module



gravity~make a modulation value rise and fall with physics
~gravity~the gravitational force to apply downwards
~kick amt~the amount of upward force to apply when kicking
~drag~the resistance force to apply opposite the velocity
~kick~click to apply kick force (or, pulse this module for the same result)



fubble~draw on an X/Y pad and replay the drawing to modulate values. based on a concept proposed by olivia jack
~quantize~should we quantize playback to a specified rhythmic interval?
~length~the interval to quantize to
~speed~speed up or slow down playback
~clear~clear the drawing
~mutate amount~amount to affect drawing by perlin noise field
~mutate warp~scale of perlin noise field
~mutate noise~rate to move through perlin noise field
~reseed~jump to a different location in the perlin noise field



expression~shape modulation with a text-based mathematical expression
~y=~expression to modify input. try something like "x+sin(x*pi*a)". available variables: a,b,c,d,e = the sliders below. t = time.
~input~input to use as x variable
~a~variable to use in expressions
~b~variable to use in expressions
~c~variable to use in expressions
~d~variable to use in expressions
~e~variable to use in expressions



envelope~modulate a value with a triggered envelope
~advanced~switch to advanced envelope editor (allows for a more complicated envelope than just an ADSR). double-click on an advanced envelope line to add stages, right click on points to remove them, drag on lines to bend them.
~adsr~envelope view
~adsrA~envelope attack
~adsrD~envelope decay
~adsrS~envelope sustain
~adsrR~envelope release
~low~output low value
~high~output high value
~length~length of envelope display
~use velocity~should envelope output be scaled by input velocity?
~has sustain~should this envelope have a sustain stage?
~sustain stage~which step of the envelope should have the sustain?
~max sustain~what's the maximum length of the sustain, in milliseconds? a value of -1 indicates no maximum



curvelooper~modulate a value over time with a looping curve
~length~length of the loop
~randomize~create a random curve



curve~remap an input over its range with a curve. double-click on the curve to add points, right click on points to remove them, drag on lines to bend them.
~input~input value (intended as a modulation target)



controlsequencer~modulate a control step-wise at an interval
~interval~rate to advance
~length~length of the sequence
~random~randomize sequence values
~step *~value for this step



audiotocv~use an audio signal to modulate a control. allow for audio-rate modulation, to achieve effects such as FM.
~gain~multiply incoming audio
~min~minimum output value
~max~maximum output value



addcentered~outputs the result of value 1 plus value 2, multiplied by range 2. optimized for using to modulation value 1 by range 2 at a frequency. value 1 or value 2 are intended to be patch targets for modulators.
~value 1~center value
~value 2~modulation value
~range 2~modulation amount



add~outputs the result of value 1 plus value 2. value 1 and value 2 are intended to be patch targets for modulators.
~value 1~value to sum
~value 2~value to sum



accum~accumulate a value over time
~value~output value
~velocity~amount to accumulate



slidersequencer~trigger notes along a continuous timeline
~division~rate to progress
~time*~time to trigger this element
~vel*~velocity of this element
~note*~pitch for this element
~playing*~is this element playing?



randomnote~play a note at a given interval with a random chance
~interval~the note length
~probability~the chance that a note will play each interval
~pitch~the pitch to use
~velocity~the velocity to use
~offset~the amount of time to offset playback within the interval
~skip~after a note plays, don't play a note the next n-1 times that it would have played



push2control~use an ableton push 2 to control bespoke's interface



polyrhythms~looping sequence with lines on different divisions
~length*~number of steps for this line
~note*~pitch to use for this line



playsequencer~drum sequencer that allows you to punch in to record and overdub steps, inspired by the pulsar-23 drum machine
~grid~patch a grid in here from a "midicontroller" module
~interval~the step size
~measures~the loop length
~write~if the current input should be written to the sequence. this will also delete steps if mute/delete is enabled for this row
~note repeat~if held notes should repeat every step
~link columns~if the mute/delete control should be shared across the entire column
~store*~store the current sequence to this slot
~load*~load the sequence stored in this slot
~mute/delete*~if write is disabled, mute this row. if write is enabled, clear the steps as the playhead passes them



notesinger~output a note based on a detected pitch
~oct~octave to adjust output pitch by



notesequencer~looping sequence of notes at an interval. pair with a "pulser" module for more interesting step control. hold "shift" to adjust step length.
~interval~note length
~random~randomize pitch, length, and velocity of all steps.
~pitch~randomize pitches in the sequence. hold shift to constrain the randomization to only pick roots and fifths.
~len~randomize the length of each step's note.
~vel~randomize the velocity of each step's note.
~length~length that the sequence below should play. the overall grid length can be changed by adjusting "gridsteps" in the triangle menu.
~<~shift the sequence to the left
~>~shift the sequence to the right
~clear~clear all steps
~octave~octave of the bottom pitch of this sequence
~notemode~which set of pitches should the rows represent?
~loop reset~when sequence loops, reset to here instead. send a "downbeat"-style message from a pulser to restart the sequence from the first step.
~tone*~pitch for this column
~vel*~velocity for this column
~len*~length for this column
~grid~patch a grid in here from a "midicontroller" module
~x offset~x offset of attached grid controller
~y offset~y offset of attached grid controller
~rand pitch chance~when clicking the random pitch button, what is the chance that a step gets changed?
~rand pitch variety~how many different random pitches should we generate?
~rand len chance~when clicking the random length button, what is the chance that a step gets changed?
~rand len range~when clicking the random length button, how much will the length change?
~rand vel chance~when clicking the random velocity button, what is the chance that a step gets changed?
~rand vel density~when clicking the random velocity button, what are the chances that a step should have a note?



notetable~map a pitch (starting from zero) to a scale pitch
~random pitch~randomize pitches in the sequence. hold shift to constrain the randomization to only pick roots and fifths.
~length~the number of pitches
~octave~octave of the bottom pitch of this sequence
~notemode~which set of pitches should the rows represent?
~tone*~pitch for this column
~grid~patch a grid in here from a "midicontroller" module
~x offset~x offset of attached grid controller
~y offset~y offset of attached grid controller
~rand pitch chance~when clicking the random pitch button, what is the chance that a step gets changed?
~rand pitch range~when clicking the random pitch button, how far will the pitch change?



notelooper~note loop recorder with overdubbing and replacement functionality
~write~should input should be recorded?
~del/mute~if "write" is enabled, erase notes as the playhead passes over them. otherwise, just mute them.
~num bars~set loop length in measures
~clear~clear pattern
~store*~save pattern
~load*~restore pattern
~canvas~canvas of recorded notes



notecreator~create a one-off note
~pitch~output note pitch
~trigger~press to trigger note for specified duration
~on~turn on to start note, turn off to end note
~velocity~note velocity
~duration~note length when "trigger" button is used



notecounter~advance through pitches sequentially. useful for driving the "notesequencer" or "drumsequencer" modules.
~interval~rate to advance
~sync~if the output pitch should be synchronized to the global transport
~start~pitch at the start of the sequence
~length~length of the sequence
~random~output random pitches within the range, rather than sequential
~div~measure division, when using "div" as the interval



notechain~trigger a note, followed by a pulse to trigger another note after a delay
~pitch~pitch to play
~trigger~play note for this chain node
~velocity~velocity for note
~duration~duration of note, in measures
~next~interval until sending pulse



notecanvas~looping note roll
~quantize~quantize selected notes to interval
~save midi~export canvas contents to a midi file
~load midi~import canvas contents from a midi file
~loadtrack~which track number to import when using "load midi"
~play~play notes on canvas
~rec~record input notes to canvas
~free rec~enable record mode, and extend canvas if we reach the end
~measures~loop length
~show chord intervals~show brackets to indicate chord relationships
~interval~interval to quantize to
~canvas~canvas of notes. canvas controls:\n-shift-click to add a note\n-hold shift and drag a note to duplicate\n-hold alt to drag a note without snapping\n-hold ctrl while dragging to snap to an interval\n-hold shift and scroll to zoom\n-hold alt and grab empty space to move slide the canvas view\n-hold ctrl and grab empty space to zoom the canvas view
~timeline~control loop points
~delete~delete highlighted elements
~view rows~number of visible rows
~clear~delete all elements
~drag mode~direction that elements can be dragged
~scrollh~horizontal scrollbar
~scrollv~vertical scrollbar



midicontroller~get midi input from external devices. to get a nice display in the "layout" view, create a .json file with the same name as your controller to describe your controller's layout, and place it in your "data/controllers" directory. look at the other files in that directory for examples.
~controller~midi device to use
~mappingdisplay~which mapping view to see
~bind (hold shift)~when this is enabled, you can map a midi input to a UI control by hovering over a UI control, holding shift, and then using desired midi input
~page~select which page of midi controls to use. each page acts like an independent midi controller, so you can use pages to allow one midi controller to switch between controlling many things
~add~add a mapping manually
~osc input port~port to use for osccontroller input
~messagetype~type of midi message
~control~pitch or control to refer to
~channel~which channel to pay attention to
~path~path to the control that should be affected. you can also enter "hover" here, to affect whichever control the mouse is hovering over.
~controltype~how this control should modify the target.\n -slider: set the value interpolated between "midi off" and "midi on" to the slider's value\n -set: set the specified value directly when this button is pressed\n -release: set the specified value directly when this button is released\n -toggle: toggle the control's value to on/off when this button is pressed\n -direct: set the control to the literal midi input value
~value~the value to set
~midi off~the lower end of the midi range. send this value when the targeted control is off. if "scale" is enabled, this also controls the lower end of the slider range, and you can set midi off to be higher than midi on to reverse a slider's direction.
~midi on~the upper end of the midi range. send this value when the targeted control is on. if "scale" is enabled, this also controls the upper end of the slider range, and you can set midi off to be higher than midi on to reverse a slider's direction.
~scale~should the output of this midi slider be scaled between "midi off" and "midi on"?
~blink~when the targeted control is enabled, send alternating on/off messages, to blink the associated LED
~increment~when "controltype" is "set" or "release", the targeted control is incremented by this amount (and the "value" field is ignored). when "controltype" is "slider", the targeted control is changed by this amount in the direction the control was changed (this setting is useful for "infinite encoders")
~twoway~should we send feedback to the controller? (to control the LEDs associated with the button/knob)
~feedback~which cc or note should we send the feedback to?
~pageless~should this connection work across all pages of the midicontroller?
~ x ~delete this connection
~copy~duplicate this connection
~layout~which layout file should we use for this controller? these can be created in your Documents/BespokeSynth/controllers folder.
~monome~which monome should we use?



keyboarddisplay~displays input notes on a keyboard, and allows you to click the keyboard to create notes



gridkeyboard~grid-based keyboard, intended primarily for 64-pad grid controllers
~layout~keyboard style
~octave~base octave
~latch~latch key presses, so you press once to play a note, and press again to release a note
~arrangement~what style of layout should we use?
~ch.latch~latch chord button presses
~p.root~for chorder, make root note always play
~grid~patch a grid in here from a "midicontroller" module



fouronthefloor~sends note 0 every beat, to trigger a kick drum
~two~sends note only every two beats



drumsequencer~step sequencer intended for drums. hold shift when dragging on the grid to adjust step velocity.
~vel~velocity to use when setting a step
~measures~length of the sequence in measures
~preset~select a pattern preset
~yoff~vertical offset for grid controller's view of the pattern
~offsets~show "offsets" sliders
~repeat~repeat input notes at this rate
~step~length of each step
~column~current column, to use for visualizing the step on a midi controller
~<~shift whole pattern one step earlier
~>~shift whole pattern one step later
~grid~patch a grid in here from a "midicontroller" module
~velocity~patch a grid in here from a "midicontroller" module to control the velocity
~metastep~patch a grid in here from a "midicontroller" module to control the "meta step". I forget what this does. oops.
~rowpitch*~output pitch for this row
~offset*~shift row forward/backward in time. try making your snares a little early, your hats a little late, etc.
~randomize~randomize the sequence
~r den~density of the randomizer output. the higher this is, the busier the random output will be.
~r amt~the chance that each step will change when being randomized. low values will only change a small amount of the sequence, high values will replace more of the sequence.
~r lock*~lock this row so it doesn't get randomized
~random*~randomize this row



helpdisplay~displays help information
~show tooltips~displays these tooltips. you can also toggle them with the F1 key, and you can turn these on or off by default in the "settings" menu.
~copy build info~copy info about this build to the clipboard, for help requests
~help page~which page of help information to show



multitrackrecorder~record several synchronized tracks of audio, to write to disk for mixing in an external DAW
~record~record input to the tracks
~bounce~write the tracks to your recordings directory
~add track~add an additional track
~clear~clear the audio in the tracks



multitrackrecordertrack~a track in a multitrack recorder
~ X ~delete this track



circlesequencer~polyrhythmic sequencer that displays a loop as a circle
~length*~number of steps in this ring
~note*~pitch to use for this ring
~offset*~timing offset for this ring



waveshaper~waveshaping with expressions
~y=~waveshaping expression. try something like "x+sin(x*pi*a)". available variables: a,b,c,d,e = the sliders below. t = time. x1,x2,y1,y2 = biquad state storage.
~rescale~rescales input before feeding it into expression
~a~variable to use in expressions
~b~variable to use in expressions
~c~variable to use in expressions
~d~variable to use in expressions
~e~variable to use in expressions



waveformviewer~waveform display
~freq~frequency to sync display to. gets automatically set if you patch a note input into this module
~length~number of samples to capture
~draw gain~adjust waveform display scale



vocodercarrier~connect to "vocoder" or "fftvocoder" modules. send the synth audio into this module, and the voice audio into the vocoder module.



vocoder~frequency band-based vocoder. this must be paired with a "vocodercarrier" module. voice should be routed into this module, and a synth should be patched into the vocodercarrier.
~input~input signal gain
~carrier~carrier signal gain
~volume~output gain
~mix~how much original input vs vocoded signal to output
~max band~volume limit for each frequency band
~spacing~how frequency bands should be spaced
~bands~how many frequency bands to use
~f base~frequency for lowest band
~f range~frequency range to highest band
~q~resonance of the bands
~ring~how long it should take the bands to "cool down"



takerecorder~[abandoned module, possibly broken]
~start~[todo]



stutter~captures and stutters input
~grid~patch a grid in here from a "midicontroller" module
~half note~half note stutter
~quarter~quarter note stutter
~8th~8th note stutter
~16th~16th note stutter
~32nd~32nd note stutter
~64th~64th note stutter
~reverse~reversed half note stutter
~ramp in~stutter with speed climbing up from zero to one
~ramp out~stutter with speed quickly falling to zero
~tumble up~accelerating stutter
~tumble down~decelerating stutter
~half speed~stutter at half speed, low pitched
~double speed~stutter at double speed, high pitched
~triplets~stutter on a triplet interval
~dotted eighth~stutter on a dotted eighth interval
~free~stutter with the settings specified by the following sliders
~free length~length in seconds for "free" stutter mode
~free speed~rate for "free" stutter mode



splitter~splits a stereo signal into two mono signals, or duplicates a mono signal



spectrum~display audio signal's spectral data



signalclamp~clamps an audio signal's value within a range
~min~minimum output value
~max~maximum output value



send~duplicate a signal and send it to a second destination
~amount~amount to send out the right-side cable
~crossfade~when true, output of the left-side cable is reduced as "amount" increases



samplergrid~record input onto pads, and play back the pads. intended to be used with an 64-pad grid controller.
~passthrough~should the incoming audio pass through to the output?
~vol~the output volume
~clear~when enabled, clears any pressed grid squares
~edit~enable controls to adjust recorded sample for last pressed grid square
~duplicate~what enabled, duplicates last pressed sample onto any pressed grid squares
~start~sample start
~end~sample end
~grid~patch a grid in here from a "midicontroller" module



samplecapturer~[work in progress]record audio to short clips. recording starts when audio passes a threshold.
~record~should we record?
~play~play this clip
~save~save this clip to a file
~delete~clear this clip



ringmodulator~modulate a signal's amplitude at a frequency
~freq~frequency to use. can also be set by patching a note input into this module.
~dry/wet~how much of the original audio to use vs modulated audio
~volume~volume output
~glide~how long an input note should take to glide to the desired frequency



pitchchorus~output pitch-shifted version of input audio, based on input midi notes. pitch 60 is the reference pitch used.
~passthrough~should the original audio pass through?



panner~pan audio left and right. also, converts a mono input to a stereo output.
~pan~amount to send signal to the left and right channels. a value of .5 is centered.
~widen~delay a channel by this many samples. results in a pan-like effect where the sound seems to come from from a direction.



output~route audio in here to send it to an output channel (your speakers or audio interface)
~ch~channel (or channels, if you want stereo) to send audio to



multitapdelay~delay with multiple tap points
~dry~how much dry signal to allow through
~display length~length of buffer display, in seconds
~delay *~tap delay time, in milliseconds
~gain *~tap delay amount
~feedback *~how much delayed audio from this tap should feed back in to the input
~pan *~stereo pan for this tap



looperrewriter~rewrites the contents of a looper with received input, to help you resample your own loops. attach the grey dot to a "looper" module.\n\nthe ideal way to use this module is to hook the "looper" directly up to a "send", hook the leftmost outlet of the "send" up to your effects processing (like an "effectchain"), hook the effect processing up to this "rewriter", and then also connect the rightmost outlet of the "send" up to this "rewriter"
~ go ~rewrite the connected looper, and if that looper is connected to a send, set that send to output only to the right outlet
~new loop~start recording a dynamic loop length. press "go" when you want to rewrite it to the looper. this will also change bespoke's global tempo to match this new loop, so it's quite powerful and scary! click it again to cancel.



looperrecorder~command center to manage recording into multiple loopers, and allow retroactive loop capture (i.e., always-on recording)
~1~capture the last measure to the currently-targeted looper
~2~capture the last 2 measures to the currently-targeted looper
~4~capture the last 4 measures to the currently-targeted looper
~8~capture the last 8 measures to the currently-targeted looper
~length~length in measures to use when connected loopers use the "commit" button
~2xtempo~double global transport tempo, while keeping connected loopers sounding the same
~.5tempo~halve global transport tempo, while keeping connected loopers sounding the same
~target~looper to commit audio to when using the on-buffer capture buttons to the left
~mode~recorder mode: use "record" to record input and allow it to be committed to buffers when you're ready to loop, use "overdub" to record input and play the loop at our specified length, and use "loop" to play the current loop without adding input
~clear~clear the recorded buffer
~free rec~enable to start recording a loop with no predetermined length. disable to end recording, adjust global transport to match the loop length, and switch the recorder's mode to "loop"
~cancel free rec~if "free rec" is enabled, cancel recording without setting the loop length
~orig speed~reset looper to tempo that loops were recorded at
~snap to pitch~snap tempo to nearest value that matches a key
~resample~resample all connected loopers to new tempo
~resample & set key~snap tempo to nearest value that matches a key (based upon the current key and the tempo change), resample all connected loopers to that new tempo, and change global scale to the new key



looper~loop input audio. use with a "looperrecorder" for full functionality.
~num bars~loop length in measures
~clear~clear the loop audio
~volume~output volume
~b~bake current volume into waveform
~ m ~take the contents of this looper and merge it into another. click this button on the merge source, then on the merge target.
~decay~amount to lower volume each loop
~save~save this loop to a wav file
~mute~silence this looper
~commit~commit the current looperrecorder buffer to this loop
~capture~when the next loop begins, record input for the duration of the loop
~write~write input audio to loop buffer
~swap~swap the contents of this looper and with another. click this button on two loopers to swap them.
~copy~take the contents of this looper and copy it onto another. click this button on the copy source, then on the copy target.
~2x~make loop play at double speed
~.5x~make loop play at half speed
~undo~undo last loop commit
~offset~amount to offset looper's playhead from transport position
~set~shift the contents of the looper so the current offset is the start of the buffer
~scrspd~playback speed, used with "scr" is enabled. modulate quickly for a vinyl-like scratching effect.
~scr~allow loop to be scratched by adjusting "scrspd"
~fourtet~use a textural trick I saw four tet illustrate in a video once: slice the audio into chunks, and for each chunk it at double speed followed by playing it in reverse at double speed. this slider adjusts the mix between the original audio and this "fourtetified" audio.
~fourtetslices~chunk size to use for "fourtet" effect
~beatwheel on~[none]
~beatwheel pos right~[none]
~beatwheel depth right~[none]
~beatwheel pos left~[none]
~beatwheel depth left~[none]
~beatwheel single measure~[none]
~pitch~amount to pitch shift looper output
~auto~should pitch shift auto-adjust as the transport tempo adjusts?
~resample for tempo~this button appears when the current global tempo no longer matches the tempo that the buffer was recorded at. click this to resample the buffer to match the new tempo.



lissajous~draw input audio as a lissajous curve. turn off "autocorrelation" in the module's triangle menu to use stereo channels to show stereo width.
~scale~visual scale of lissajous image



inverter~multiply a signal by -1. enables some pretty interesting effects when used with sends, to subtract out parts of signals when recombined.



input~get audio from input source, like a microphone
~ch~which channel (or channels, if you want stereo) to use



freqdelay~delay effect with delay length based upon input notes
~dry/wet~how much of the effect to apply



fftvocoder~FFT-based vocoder
~input~input signal gain
~carrier~carrier signal gain
~volume~output gain
~dry/wet~how much original input vs vocoded signal to output
~fric thresh~fricative detection sensitivity, to switch between using the carrier signal and white noise for vocoding
~whisper~how much the carrier signal partial's phases should be randomized, which affects how whispery the output sound is
~phase off~how much we should offset the phase of the carrier signal's partials
~cut~how many bass partials to remove



feedback~feed delayed audio back into earlier in the signal chain. use the "feedback out" connector for sending the audio back up the chain, and the primary output connector for sending the resulting audio forward. using feedback can often lead to extreme and difficult-to-control results!
~limit~clip the feedback audio to this range, to avoid issues with feedback blowing out too intensely.



eq~multi-band equalizer, to adjust output levels at frequency ranges
~enabled*~enable this band?
~type*~what type of filter should this band use
~f*~frequency cutoff for this band
~g*~gain for this band
~q*~resonance for this band



effectchain~container to hold a list of effects, applied in series. the effects can be easily reordered with the < and > buttons, and deleted with the x button. hold shift to expose a x button for all effects.
~volume~output gain
~effect~select which effect to add
~spawn~spawn the currently highlighted effect
~exit effect~on push2, back effect control out to the main effectchain controls
~<~move this effect to earlier in the chain
~>~move this effect to later in the chain
~x~delete this effect
~mix*~wet/dry slider for this effect



basiceq~simple multiband EQ
~even~reset EQ



biquad~filter using biquad formula
~type~filter type
~F~frequency cutoff
~Q~resonance
~G~gain



bitcrush~reduce sample resolution and sample rate for lo-fi effects
~crush~sample resolution reduction
~downsamp~sample rate reduction



butterworth~filter using the butterworth formula
~F~frequency cutoff
~Q~resonance



compressor~try to keep volume at a certain level
~mix~amount of compression. lower this value for a "parallel compression" effect. you should use this mix slider instead of the effectchain's mix slider, to compensate for lookahead.
~drive~rescale input to affect how much compression affects it
~threshold~threshold where gain should start to be reduced
~ratio~how much gain reduction to apply when the single passes the threshold
~attack~speed to apply gain reduction
~release~speed to remove gain reduction
~lookahead~how much time to "look ahead" to adjust the compression envelope. this necessarily introduces a delay into your output, which could be compensated for by running sequencers slightly early.
~output~makeup gain, to increase volume



dcremover~high pass filter with a 10hz cutoff to remove DC offset, to keep signal from drifting away from zero



delay~echoing delay
~delay~delay in milliseconds
~amount~amount of delay that returns
~interval~sets delay length to a musical duration
~short~shortcut to shrink the range of the delay slider, to allow for audible-rate delays and comb filter sounds
~dry~should the dry signal pass through, or just the delayed signal?
~feedback~should the output audio feed back into the delay?
~input~should we accept input into the delay?
~invert~should the delayed audio have its signal inverted? this can give a different sound, and also cancel out DC offset to prevent it from accumulating with feedback.



distortion~waveshaping distortion
~type~style of distortion to apply
~clip~cutoff point of distortion, lower values result in more extreme distortion
~preamp~signal gain before feeding into distortion
~fuzz~push input signal off-center to distort asymmetrically
~center input~remove dc offset from input signal to distort in a more controlled way



formant~[unfinished, broken]filter focused on controlling formants
~ee~[todo]
~oo~[todo]
~i~[todo]
~e~[todo]
~u~[todo]
~a~[todo]



freeverb~reverb using the "freeverb" algorithm
~room size~controls the length of the reverb, a higher value means longer reverb
~damp~high frequency attenuation; a value of zero means all frequencies decay at the same rate, while higher settings will result in a faster decay of the high frequency range
~wet~amount of reverb signal
~dry~amount of untouched signal
~width~stereo width of reverb



gainstage~control volume within an effectchain
~gain~volume multiplier



gate~only allow signal in when it's above a certain threshold. useful to eliminate line noise, or just as an effect.
~threshold~volume threshold to open up the gate
~attack~speed at which gate blends open
~release~speed at which gate blends closed



granulator~granulate live input
~overlap~number of overlapping grains
~speed~speed of grain playback
~len ms~length of each grain in milliseconds
~dry~amount of dry signal to allow through
~autocapture~freeze input at this interval
~pos r~randomization of grain start point
~spd r~randomization of grain speed
~spa r~randomization of time between grains
~frz~freeze the current recorded buffer
~g oct~should we add octaves and fifths?
~width~stereo width of grain placement
~pos~playback position within the buffer



muter~mute an incoming signal
~pass~when true, the signal is allowed through
~ms~ramp time to mute/unmute signal



noisify~multiply input signal by white noise
~amount~amount of noise to apply
~width~how frequently a new noise sample should be chosen



pitchshift~shifts a signal's pitch
~ratio~amount to pitchshift by (a value of 1 indicates no shift)
~ratioselector~shortcuts to useful pitch ratios



pumper~dip the volume of a signal rhythmically, to emulate a "pumping sidechain" effect
~amount~amount to lower volume
~length~length of pump
~curve~how the volume returns
~attack~how sharply the volume drops
~interval~the rate to pump



tremolo~modulate signal's volume rhythmically
~amount~amount to lower volume
~offset~offsets LFO phase
~duty~pulse width of LFO
~interval~speed of LFO
~osc~LFO oscillator type



dcoffset~add a constant offset to an audio signal
~offset~amount of offset to add



autotalent~[abandoned module, possibly broken]autotune using the "autotalent" code
~A~[todo]
~Bb~[todo]
~B~[todo]
~C~[todo]
~Db~[todo]
~D~[todo]
~Eb~[todo]
~E~[todo]
~F~[todo]
~Gb~[todo]
~G~[todo]
~Ab~[todo]
~amount~[todo]
~smooth~[todo]
~shift~[todo]
~scwarp~[todo]
~lfoamp~[todo]
~lforate~[todo]
~lfoshape~[todo]
~lfosymm~[todo]
~lfoquant~[todo]
~formant correct~[todo]
~fwarp~[todo]
~mix~[todo]
~set from scale~[todo]



audiorouter~selector for switching where audio is routed to. connect to targets to add them to the list.
~route~audio destination



audiometer~sets a slider to an audio level's volume. useful to map a midi display value to.
~level~the input audio level. hook this up to an LED-display midi control to see the value displayed on your controller.



signalgenerator~basic oscillator signal. send a note into it to set the frequency, and send a pulse to reset the phase.
~freq~signal frequency
~freq mode~what mode should we use for input notes? "instant" changes to the input note's frequency instantly, "ramp" ramps to the frequency over time, and "slider" allows you to use a slider to interpolate between the last two input notes
~osc~oscillator type
~pw~pulse width (or shape for non-square waves)
~slider~slider to interpolate between last two input pitches
~ramp~amount of time to ramp to input frequency
~sync~turns on "sync" mode, to reset the phase at syncf's frequency
~syncf~frequency to reset the phase, when "sync" is enabled
~soften~soften edges of square and saw waveforms
~shuffle~stretches and squeezes every other cycle of the waveform
~mult~multiplier for frequency
~phase~phase offset
~vol~output volume
~detune~amount to detune from specified frequency



seaofgrain~granular synth, playable with sliders or MPE input
~load~load a sample file
~record~record input as the granular buffer, to use seaofgrain a live granular delay
~volume~output volume
~offset~where to start view of the sample
~display length~amount of sample to view
~keyboard base pitch~midi pitch that represents the start of the sample
~keyboard num pitches~amount of pitches to assign across the sample
~gain *~volume of this voice
~pos *~position of this voice within the sample
~overlap *~number of overlapping grains
~speed *~speed of grain playback
~len ms *~length of each grain in milliseconds
~pos r *~randomization of grain start point
~speed r *~randomization of grain speed
~spacing r*~randomization of time between grains
~octaves *~should we add octaves and fifths?
~width *~stereo width of grain placement
~pan *~stereo panorama of grain placement



sampler~very basic polyphonic pitched sample player and recorder. send audio in, and use note input to play the recorded audio.
~vol~output volume
~env~volume envelope
~envA~volume envelope attack
~envD~volume envelope decay
~envS~volume envelope sustain
~envR~volume envelope release
~rec~enable to clear the current recording, and record new audio once the input threshold is reached
~thresh~when recording is enabled, exceed this threshold with input audio to begin recording
~pitch~should we attempt pitch-correct the audio?
~passthrough~should input audio pass through as we're recording?



sampleplayer~sample playback with triggerable cue points, clip extraction, and youtube search/download functionality. resize this module larger to access additional features. if you have a youtube URL in your clipboard, a button will appear to allow you to download the audio.
~volume~output gain
~speed~current playback speed
~yt:~search youtube for this string
~play~start playing from the current playhead
~pause~pause playing and leave playhead where it is
~stop~stop playing and reset playhead
~loop~wrap playhead to beginning when it reaches end
~load~show a file chooser to load a sample
~save~save this sample to a file
~record~record audio input into our sample buffer. clears the current sample.
~trim~discard all audio outside the current zoom range
~youtube~download the audio of the youtube URL currently on your clipboard
~cue start~start point in seconds of the current cue
~cue len~length in seconds of the current cue. a value of zero will play to the end of the sample.
~cue speed~playback speed of the current cue
~cue stop~stop playing this cue if a note-off is received
~cuepoint~sets the current cue to edit
~click sets cue~when true, clicking on the waveform will set the start position of the current cue
~select played~when true, any cue point played via incoming notes will become the current cue
~play cue~play the current cue
~show grid~show a quarter note grid (when zoomed in far enough)
~4~auto-slice 4 slices
~8~auto-slice 8 slices
~16~auto-slice 16 slices
~32~auto-slice 32 slices
~searchresult*~click to download this youtube search result. downloading long videos may take a while.
~append to rec~when recording, append to the previous recording, rather than clearing the sample first
~record as clips~when recording, only record when there is enough input to open the gate, and mark up each recorded segment with cue points
~threshold~volume threshold to open up the gate for recording
~attack~speed at which gate blends open
~release~speed at which gate blends closed
~playhovered~play this cue
~grabhovered~grab a sample of this cue to drop onto another module



samplecanvas~sample arranging view
~measures~length of canvas in measures
~interval~grid subdivision interval
~canvas~canvas of samples. drag and drop samples onto here. canvas controls:\n-hold shift and drag a sample to duplicate\n-hold alt to drag a sample without snapping\n-hold ctrl while dragging to snap to an interval\n-hold shift and scroll to zoom\n-hold alt and grab empty space to move slide the canvas view\n-hold ctrl and grab empty space to zoom the canvas view
~timeline~control loop points
~scrollh~horizontal scrollbar
~scrollv~vertical scrollbar
~delete~delete highlighted elements
~view rows~number of visible rows
~clear~delete all elements
~drag mode~direction that elements can be dragged



oscillator~polyphonic enveloped oscillator. modulations (with MPE support): modwheel closes filter further (if filter is enabled), pressure decreases detune amount
~osc~oscillator type
~mult~multiply frequency of incoming pitch
~pw~pulse width (or shape for non-square waves)
~shuffle~stretches and squeezes every other cycle of the waveform
~soften~soften edges of square and saw waveforms
~phase~phase offset of oscillator, and phase offset between unison voices. useful to patch into with a very fast modulator, to achieve phase modulation.
~sync~turns on "sync" mode, to reset the phase at syncf's frequency
~syncf~frequency to reset the phase, when "sync" is enabled
~env~[none]
~envA~volume envelope attack
~envD~volume envelope decay
~envS~volume envelope sustain
~envR~volume envelope release
~vol~this oscillator's volume
~detune~when unison is 1, detunes oscillator by this amount. when unison is 2, one oscillator is tuned normally and the other is detuned by this amount. when unison is >2, oscillators are randomly detuned within this range.
~unison~how many oscillators to play for one note
~width~controls how voices are panned with unison is greater than 1
~adsr len~view length of ADSR controls
~envfilter~[none]
~envfilterA~filter envelope attack
~envfilterD~filter envelope decay
~envfilterS~filter envelope sustain
~envfilterR~filter envelope release
~fmax~frequency cutoff of lowpass filter at the max of the envelope. set this slider to the max to disable the filter
~fmin~frequency cutoff of lowpass filter at the min of the envelope
~q~resonance of lowpass filter
~vel2vol~how much should the input velocity affect the output volume?
~vel2env~how much should the input velocity affect the speed of the volume and filter envelopes?
~lite cpu~only recalculate some parameters once per buffer, to reduce CPU load. can make pitch bends and rapid modulation sound worse in some scenarios.



metronome~beeps to the beat
~vol~metronome volume



karplusstrong~polyphonic plucked string physical modeling synth
~vol~output volume
~invert~should the feedback invert?
~filter~amount to filter resonance
~feedback~amount of feedback for resonance
~source type~audio to use for excitation
~x freq~frequency of excitation audio
~x att~fade in time for excitation audio
~x dec~fade out time for excitation audio
~vel2vol~how much velocity should affect voice volume
~vel2env~how much velocity should affect excitation attack time
~pitchtone~adjust how pitch influences filter amount. a value of zero gives even filtering across the entire pitch range, higher values filter high pitches less, low values filter low pitches less.
~lite cpu~only recalculate some parameters once per buffer, to reduce CPU load. can make pitch bends and rapid modulation sound worse in some scenarios.



lfo~modulates a slider with a low-frequency oscillator
~enable~turn on/off modulation
~pin~make LFO window remain visible
~interval~length of oscillation period
~osc~type of oscillation waveform
~offset~phase offset, to make oscillation earlier/later
~free rate~rate of oscillator running in non-clock-synced time
~low~output value at waveform's low point
~high~output value at waveform's high point
~spread~spread the waveform out to be closer to the low and high points
~bias~bias the waveform towards the low or high point
~length~proportion of time that should be spent on the waveform cycle
~shuffle~adjust the waveoform to have a fast and slow cycle
~soften~smooth out the hard edges of square and saw waveforms
~lite cpu~only recalculate some parameters once per buffer, to reduce CPU load. can sound worse in some scenarios, especially with rapid modulation.



fmsynth~polyphonic fm synthesis
~adsrosc~
~adsroscA~
~adsroscD~
~adsroscS~
~adsroscR~
~adsrharm~
~adsrharmA~
~adsrharmD~
~adsrharmS~
~adsrharmR~
~adsrmod~
~adsrmodA~
~adsrmodD~
~adsrmodS~
~adsrmodR~
~adsrharm2~
~adsrharm2A~
~adsrharm2D~
~adsrharm2S~
~adsrharm2R~
~adsrmod2~
~adsrmod2A~
~adsrmod2D~
~adsrmod2S~
~adsrmod2R~
~harmratio~harmonic ratio of first-order modulator to input pitch
~harmratio2~harmonic ratio of second-order modulator to input pitch
~tweak~multiplier to harmonic ratio for first-order modulator
~mod~amount to modulate first-order modulator
~tweak2~multiplier to harmonic ratio for second-order modulator
~mod2~amount to modulate second-order modulator
~vol~the output volume
~phase0~phase offset for base oscillator
~phase1~phase offset for first-order modulator
~phase2~phase offset for second-order modulator



notetoggle~turn a control on or off depending on if there are any input notes



drumsynth~oscillator+noise drum synth
~vol~the output volume
~edit~display parameters for each hit
~adsrtone*~
~adsrtone*A~
~adsrtone*D~
~adsrtone*S~
~adsrtone*R~
~vol*~oscillator volume
~adsrnoise*~
~adsrnoise*A~
~adsrnoise*D~
~adsrnoise*S~
~adsrnoise*R~
~noise*~noise volume
~type*~oscillator type
~adsrfreq*~
~adsrfreq*A~
~adsrfreq*D~
~adsrfreq*S~
~adsrfreq*R~
~freqmax*~oscillator start frequency
~freqmin*~oscillator end frequency
~adsrfilter*~
~adsrfilter*A~
~adsrfilter*D~
~adsrfilter*S~
~adsrfilter*R~
~cutoffmax*~filter start cutoff frequency
~cutoffmin*~filter end cutoff frequency
~q*~filter resonance
~oversampling~oversampling amount. increases sound quality, but also increases cpu usage.



drumplayer~sample player intended for drum playback
~vol~the output volume
~speed~global sample speed multiplier
~speed rnd~global sample speed randomization amount
~kit~[none]
~edit~show pads for editing
~aud~scroll to audition samples in the current pad's head category, or a directory last dropped onto a pad
~mono~force output to mono
~shuffle~random is samples, speeds, and pans
~grid~patch a grid in here from a "midicontroller" module
~quantize~quantize input to this interval
~repeat~if quantizing, should held notes repeat at that interval?
~vol *~volume of sample 
~speed *~speed of sample
~pan *~stereo pan position of sample
~widen *~stereo delay of sample to create width
~start *~start offset percentage of sample
~single out *~should the sample have its own individual output?
~linkid *~if linkid is not -1, silence any other sample with a matching linkid (useful for linking open and closed hats)
~envelope *~should we apply a volume envelope to the sample?
~view ms *~envelope view length in milliseconds
~hitcategory*~folder to choose from, when clicking the "random" button. these folders are found in the data/drums/hits/ directory
~envelopedisplay *~[none]
~envelopedisplay *A~envelope attack
~envelopedisplay *D~envelope decay
~envelopedisplay *S~envelope sustain
~envelopedisplay *R~envelope release
~test *~play this sample
~random *~choose a random sample from the selected hitcategory
~grab *~grab this sample
~prev *~choose the previous sample from the selected hitcategory
~next *~choose the next sample from the selected hitcategory



beats~multi-loop player, for mixing sample layers together
~volume*~layer volume
~filter*~layer filter. negative values bring in a low pass, positive values bring in a high pass.
~pan*~layer panorama
~double*~enable this to play at double speed
~bars*~how many measures long are the samples in this slot?
~selector*~which sample should we play in this slot? drag samples onto here to add them to this slot.
~delete *~remove the current sample from the list



whitekeys~remap the white keys that correspond to the C major scale to instead play the current global scale



volcabeatscontrol~outputs MIDI data to control various aspects of the KORG volca beats drum machine
~clap speed~
~clave speed~
~agogo speed~
~crash speed~
~stutter time~
~stutter depth~
~tom decay~
~closed hat decay~
~open hat decay~
~hat grain~
~level *~



vibrato~add rhythmic oscillating pitch bend to notes
~vibrato~amount of pitch bend to add
~vibinterval~speed of pitch bend oscillation



velocitytochance~use a note's velocity to determine the chance that the note plays
~full velocity~set velocity to full for notes that pass through
~beat length~restart the determined random sequence at this interval
~seed~number that determines the random sequence
~<~go to previous seed
~*~generate a new random seed
~<~go to next seed



velocitystepsequencer~adjusts the velocity of incoming notes based upon a sequence
~interval~speed to advance sequence
~len~length of sequence
~downbeat~should we reset the sequence every downbeat?
~vel*~velocity for this step



velocitysetter~set a note's velocity to this value
~vel~velocity to use
~rand~randomness to reduce output velocity by



velocityscaler~scale a note's velocity to be higher or lower
~scale~amount to multiply velocity by



velocitycurve~adjust velocity based upon a curve mapping



unstablepressure~mutate MPE pressure with perlin noise
~amount~amount of mutation
~warble~slow-layer mutation rate
~noise~fast-later mutation rate



unstablepitch~mutate MPE pitchbend with perlin noise
~amount~amount of mutation
~warble~slow-layer mutation rate
~noise~fast-later mutation rate



unstablemodwheel~mutate MPE slide with perlin noise
~amount~amount of mutation
~warble~slow-layer mutation rate
~noise~fast-later mutation rate



sustainpedal~keeps input notes sustaining
~sustain~should we hold the input notes?



scaledetect~detect which scales fit a collection of entered notes. the last played pitch is used as the root.
~reset~reset the input collection of notes
~matches~matching scales for this root



scaledegree~transpose input based on current scale
~degree~amount to transpose
~retrigger~immediately replay current notes when changing the transpose amount



quantizer~delay inputs until the next quantization interval
~quantize~the quantization interval
~repeat~when holding a note, should we repeat it every interval?



previousnote~when receiving a note on, output the prior note on that we received



pressuretovibrato~takes midi pressure modulation input and changes it to vibrato, using pitch bend
~vibrato~amount of vibrato
~vibinterval~vibrato speed



pressuretomodwheel~takes midi pressure modulation input and changes it to modwheel modulation



pressure~add pressure modulation to notes
~pressure~pressure amount



portamento~only allows one note to play at a time, and uses pitch bend to glide between notes
~mode~always: always glide to new notes\nretrigger held: bend to notes if the prior note is held, and retrigger\nbend held: bend to notes if the prior note is held, without retriggering
~glide~time to glide, in milliseconds



pitchsetter~set an incoming note to use a specified pitch
~pitch~the pitch to use



pitchremap~remap input pitches to different output pitches
~from*~pitch to change
~to*~desired pitch



pitchpanner~add pan modulation to notes based upon input pitch, so low pitches are panned in one direction and high pitches are panned in another
~left~pitch that represents full left pan
~right~pitch that represents full right pan



pitchdive~use pitchbend to settle into an input pitch from a starting offset
~start~semitone offset to start from
~time~time in milliseconds to ramp from pitch offset into input pitch



pitchbender~add pitch bend to notes
~bend~bend amount, in semitones



notewrap~wrap an input pitch to stay within a desired range
~min~bottom of pitch range
~range~number of semitones before wrapping back down to min pitch



notestrummer~send a chord into this, and move a slider to strum each note of the chord
~strum~move the slider past each note to strum it



notestream~view a stream of notes as they're played
~reset~reset the pitch range



notesorter~separate notes by pitch. any unmapped pitches go through the standard outlet.
~pitch *~pitch to use for this outlet



noterouter~allows you to control where notes are routed to using a UI control. to add destinations to the list, patch them as a target
~route~the noterouter's destination module



noteexpression~control where notes are routed based upon evaluated expressions. the variable "p" represents pitch, and "v" represents velocity
~expression*~expression to evaluate for this cable. example expression to route notes with pitch greater than 80 and velocity less than 60:\n"p > 80 && v < 60"



noteecho~output incoming notes at specified delays
~delay *~amount of time to delay this output, in measures



noteratchet~rapidly repeat an input note over a duration
~duration~total length of time repeats should last
~subdivision~length of each repeat



noterangefilter~only allows notes through within a certain pitch range
~min~minimum pitch allowed
~max~maximum pitch allowed
~wrap~instead of rejecting notes outside of this range, should we wrap them to the range instead?



notepanrandom~sets a note's pan to random values, for the internal synths that support panned notes
~spread~amount of randomness
~center~center pan position



notepanner~sets a note's pan, for the internal synths that support panned notes
~pan~pan position, .5 is centered



notepanalternator~sets a note's pan, alternating between two values, for the internal synths that support panned notes
~one~pan position, .5 is centered
~two~pan position, .5 is centered



noteoctaver~transpose a note by octaves
~octave~number of octaves to raise or lower



notelatch~use note on messages to toggle notes on and off



notehumanizer~add randomness to timing and velocity
~time~amount of timing randomness, in milliseconds.
~velocity~amount of velocity randomness



notehocket~sends notes to random destinations
~weight *~chance that note goes to this destination
~beat length~restart the determined random sequence at this interval
~seed~number that determines the random sequence
~<~go to previous seed
~*~generate a new random seed
~<~go to next seed



notegate~allow or disallow notes to pass through
~open~if notes are allowed to pass



noteflusher~send a note-off for all notes
~flush~click to flush notes



notefilter~only allow a certain pitches through
~C-2 (0)~
~C#-2 (1)~
~D-2 (2)~
~D#-2 (3)~
~E-2 (4)~
~F-2 (5)~
~F#-2 (6)~
~G-2 (7)~



noteduration~sets the length a note will play, ignoring the note-off message
~duration~length of the note in measures



notedisplayer~show input note info



notedelayer~delay input notes by a specified amount
~delay~amount of time to delay, in measures



notechance~randomly allow notes through
~chance~probability that a note is allowed
~beat length~restart the determined random sequence at this interval
~seed~number that determines the random sequence
~<~go to previous seed
~*~generate a new random seed
~<~go to next seed



mpetweaker~adjust incoming MPE modulation values
~pitchbend mult~amount to multiply incoming pitchbend
~pitchbend offset~amount to offset incoming pitchbend
~pressure mult~amount to multiply incoming pressure
~pressure offset~amount to offset incoming pressure
~modwheel mult~amount to multiply incoming modwheel
~modwheel offset~amount to offset incoming modwheel



mpesmoother~smooth out MPE parameters
~pitch~amount to smooth incoming pitchbend
~pressure~amount to smooth incoming pressure
~modwheel~amount to smooth incoming modwheel



modwheeltovibrato~convert note mod wheel input rhythmic pitch bend
~vibrato~amount of pitch bend
~vibinterval~rate of vibrato



modwheeltopressure~swaps expression input to midi pressure in the output



modwheel~adds an expression value to a note
~modwheel~expression level



modulationvizualizer~display MPE modulation values for notes



midioutput~send midi to an external destination, such as hardware or other software
~controller~where to send midi to



midicc~outputs midi control change messages to route to a "midioutput" module
~control~CC control number
~value~outputs a CC value when this changes



samplebrowser~browse your system for samples. drag samples from here to your desired targets (sampleplayer, drumplayer, seaofgrain, etc)
~ < ~previous page
~ > ~next page



linnstrumentcontrol~[work in progress]control the lights of a linnstrument controller in various ways
~controller~midicontroller with the linnstrument
~decay~amount of time it takes for lit key to die off
~blackout~turn off all lights
~octaves~when pressing a key, should we light that key for all octaves?
~guitar lines~should we use the "guitar lines" light layout?



gridnotedisplayer~use with a gridkeyboard to display currently playing notes, to visualize chords, arpeggiation, etc.



chordholder~keeps any notes pressed at the same time sustaining, until new notes are pressed
~stop~stop notes from playing
~pulse to play~when enabled, input notes aren't played immediately, but instead wait for an input pulse before playing



chorder~takes an incoming pitch and plays additional notes to form chords
~diatonic~should the grid be chromatic, or locked to the scale only?
~chord~chord presets
~inversion~inversion presets



chorddisplayer~display which chord is playing, in the context of the current scale



capo~shifts incoming notes by semitones
~capo~number of semitones to shift
~retrigger~immediately replay current notes when changing the capo amount



arpeggiator~arpeggiates held notes. there are several vestigial features in this module that should be cleaned up.
~interval~arpeggiation rate
~step~direction and distance to step through arpeggiation. a value of zero is "pingpong".
~octaves~how many octaves to step through



titlebar~
~save layout~[none]
~load~load a saved .bsk file to restore state
~save~save current state as .bsk file, to be restored later
~save as~save current state as a new .bsk file
~new patch~reset to the layout specified in "layout" in userprefs.json
~write audio~write the last 30 minutes of audio to your specified recordings_path
~ ? ~show help
~settings~adjust preferences, saved as userprefs.json
~load layout~[none]
~lookahead (exp.)~use lookahead scheduling, which is necessary for scriptmodule. gets automatically turned on when you use scriptmodule. so far, lookahead scheduling seems to not create any issues, but leaving this checkbox here just in case.
~autosave~every time a new module is added, trigger a save to data/savestate/autosave/, to help reload state in the event of a crash. can be quite slow if using modules with large samples.
~play/pause~stop all audio processing (shift-p)



newpatchconfirm~
~confirm~clear everything and start fresh
~cancel~dismiss this



vstplugin~a VST plugin instance
~vol~adjust the output volume
~program change~send a program change message to the VST instance
~open~show the plugin window
~show parameter~select parameters to display them, so they can be adjusted from within bespoke's interface. if a VST has more than 20 parameters, this list will initially be empty. in that case, to make a parameter appear in this list, wiggle it within the VST's interface.
~preset~choose from saved VST presets
~save as~save the current VST settings as a preset to load again later
~panic~send "all notes off" and "all sounds off" to this plugin in order to silence it immediately



transport~controls tempo and current time position
~tempo~global tempo, in beats per minute
~ + ~increase tempo by one
~ - ~decrease tempo by one
~swing~where the halfway point of musical time within the swing interval should fall. a value of .5 represents no swing.
~swing interval~interval over which to apply swing
~timesigtop~time signature top value
~timesigbottom~time signature bottom value
~reset~reset timeline to zero
~ < ~nudge current time backward
~ > ~nudge current time forward
~set tempo~
~play/pause~stop all audio processing (shift-p)



transposefrom~transpose input from a specified root to the root of the current scale. the primary usage of this would be to allow you to play a keyboard in C, but it gets transposed to the current scale.
~root~root to transpose from
~retrigger~immediately replay current notes when changing the transpose root or the scale



m185sequencer~sequencer using the unique paradigm of the the m185 or intellijel metropolis
~interval~interval per step
~reset step~resets counter to first step
~pitch*~pitch to use for this row
~pulses*~number of steps this row should last
~gate*~behavior for each row: "repeat" plays every step, "once" plays just the first step, "hold" holds across all steps, "rest" plays no steps





notestepper~output notes through a round robin of patch cables, to create sequential variety
~length~length of the sequence
~reset~reset to the start




splitter~splits a stereo signal into two mono signals, or duplicates a mono signal



scale~controls the global scale used by various modules
~root~root note of the scale
~scale~which set of notes to use
~degree~
~intonation~which method to use to tune the scale
~PPO~pitches per octave
~tuning~what frequency does the pitch defined in "note" represent?
~note~the pitch that maps to the frequency defined in "tuning"
~load SCL~load SCL file to determine scale
~load KBM~load KBM file to determine keyboard mapping



output~route audio in here to send it to an output channel (your speakers or audio interface)
~ch~channel (or channels, if you want stereo) to send audio to



gain~adjusts volume of audio signal
~gain~amount to adjust signal. a value of 1 will cause no change to the signal.



userprefseditor~settings for bespoke. some settings changes require bespoke to be restarted before taking effect.
~devicetype~what kind of audio device bespoke should use (requires restart)
~audio_output_device~which device to use for audio output (requires restart)
~audio_input_device~which device to use for audio input (requires restart)
~samplerate~what sample rate to use with your audio device (requires restart)
~buffersize~what buffer size to use with your audio device. lower values use require more CPU power, higher values add more latency. (requires restart)
~oversampling~global oversampling multiplier. uses additional CPU for higher-resolution audio processing. (requires restart)
~width~width of bespoke's window on startup
~height~height of bespoke's window on startup
~set_manual_window_position~should we force bespoke to a specific position on startup
~position_x~desired x position of upper-left corner
~position_y~desired y position of upper-left corner
~zoom~desired canvas zoom level on startup
~ui_scale~scale of UI layer (title bar, quickspawn menu, etc)
~grid_snap_size~grid size to use when snapping module position (hold alt/option while dragging a module)
~scroll_multiplier_vertical~adjustment to vertical mouse/trackpad scroll speed
~scroll_multiplier_horizontal~adjustment to horizontal mouse/trackpad scroll speed
~autosave~should autosave be enabled on startup
~show_tooltips_on_load~should tooltips be enabled on startup
~show_minimap~should the minimap be displayed (requires restart)
~record_buffer_length_minutes~length of always-on recording buffer for "write audio" button in the title bar (requires restart)
~vst_always_on_top~should plugin windows always stay on top of bespoke when opened
~max_output_channels~number of output channels to allocate (requires restart)
~max_input_channels~number of input channels to allocate (requires restart)
~plugin_preference_order~semicolon-separated list of plugin formats, in preferred order. if a plugin exists with multiple formats, only the most preferred format will be shown. leave this blank to always show all plugins. (default value: "VST3;VST;AudioUnit;LV2")
~draw_background_lissajous~should the background lissajous curve draw
~fade_cable_middle~should longer cables draw with a fadeout effect in the middle
~cable_quality~visual resolution of the cables
~lissajous_r~red RGB value of lissajous curve
~lissajous_g~green RGB value of lissajous curve
~lissajous_b~blue RGB value of lissajous curve
~background_r~red RGB value of canvas background
~background_g~green RGB value of canvas background
~background_b~blue RGB value of canvas background
~motion_trails~amount of visual motion blur to use (increases/decreases "ghosting" of previous frames)
~draw_module_highlights~should modules visually flash in response to activity
~mouse_offset_x~x offset between system mouse position and bespoke's cursor placement
~mouse_offset_y~y offset between system mouse position and bespoke's cursor placement
~recordings_path~where "write audio" and multitrackrecorder wav files save
~tooltips~what path we should use for the tooltip file (changing this allows for other languages to be used for tooltips)
~layout~what template bespoke should use on startup
~youtube_dl_path~the path to your youtube-dl installation (used for youtube downloading in sampleplayer module)
~ffmpeg_path~the path to your ffmpeg installation (used for youtube downloading in sampleplayer module)